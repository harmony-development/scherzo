pub mod either;
pub mod evec;
pub mod http_ratelimit;
pub mod ratelimit;
pub mod test;

use hrpc::exports::{bytes::Bytes, http};
use hyper::HeaderMap;
use rand::Rng;
pub use ratelimit::rate_limit;

use smol_str::SmolStr;

pub fn get_time_secs() -> u64 {
    std::time::UNIX_EPOCH
        .elapsed()
        .expect("time is before unix epoch")
        .as_secs()
}

pub fn gen_rand_inline_str() -> SmolStr {
    // Safety: arrays generated by gen_rand_arr are alphanumeric, so they are valid ASCII chars as well as UTF-8 chars [ref:alphanumeric_array_gen]
    let arr = gen_rand_arr::<_, 22>(&mut rand::thread_rng());
    let str = unsafe { std::str::from_utf8_unchecked(&arr) };
    // Safety: generated array is exactly 22 u8s long
    SmolStr::new_inline(str)
}

#[allow(dead_code)]
pub fn gen_rand_str<const LEN: usize>() -> SmolStr {
    let arr = gen_rand_arr::<_, LEN>(&mut rand::thread_rng());
    // Safety: arrays generated by gen_rand_arr are alphanumeric, so they are valid ASCII chars as well as UTF-8 chars [ref:alphanumeric_array_gen]
    let str = unsafe { std::str::from_utf8_unchecked(&arr) };
    SmolStr::new(str)
}

pub fn gen_rand_arr<RNG: Rng, const LEN: usize>(rng: &mut RNG) -> [u8; LEN] {
    let mut res = [0_u8; LEN];

    let random = rng
        .sample_iter(rand::distributions::Alphanumeric) // [tag:alphanumeric_array_gen]
        .take(LEN);

    random
        .zip(res.iter_mut())
        .for_each(|(new_ch, ch)| *ch = new_ch);

    res
}

pub fn gen_rand_u64() -> u64 {
    rand::thread_rng().gen_range(1..u64::MAX)
}

pub fn get_mimetype(headers: &HeaderMap) -> &str {
    headers
        .get(&http::header::CONTENT_TYPE)
        .and_then(|val| val.to_str().ok())
        .and_then(|s| s.split(';').next())
        .unwrap_or("application/octet-stream")
}

pub fn get_content_length(headers: &HeaderMap) -> http::HeaderValue {
    headers
        .get(&http::header::CONTENT_LENGTH)
        .cloned()
        .unwrap_or_else(|| unsafe {
            http::HeaderValue::from_maybe_shared_unchecked(Bytes::from_static(b"0"))
        })
}
